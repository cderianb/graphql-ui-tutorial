{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\n// src/useQuery.ts\nimport { ref as ref3, unref, computed as computed3, watch as watch2, onServerPrefetch, getCurrentInstance as getCurrentInstance3, onBeforeUnmount as onBeforeUnmount2, nextTick } from \"vue-demi\";\nimport { throttle, debounce } from \"throttle-debounce\";\n\n// src/useApolloClient.ts\nimport { getCurrentInstance, inject } from \"vue-demi\";\nvar DefaultApolloClient = Symbol(\"default-apollo-client\");\nvar ApolloClients = Symbol(\"apollo-clients\");\nfunction resolveDefaultClient(providedApolloClients, providedApolloClient) {\n  const resolvedClient = providedApolloClients ? providedApolloClients.default : providedApolloClient != null ? providedApolloClient : void 0;\n  return resolvedClient;\n}\nfunction resolveClientWithId(providedApolloClients, clientId) {\n  if (!providedApolloClients) {\n    throw new Error(`No apolloClients injection found, tried to resolve '${clientId}' clientId`);\n  }\n  return providedApolloClients[clientId];\n}\nfunction useApolloClient(clientId) {\n  let resolveImpl;\n  const savedCurrentClients = currentApolloClients;\n  if (!getCurrentInstance()) {\n    resolveImpl = id => {\n      if (id) {\n        return resolveClientWithId(savedCurrentClients, id);\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default);\n    };\n  } else {\n    const providedApolloClients = inject(ApolloClients, null);\n    const providedApolloClient = inject(DefaultApolloClient, null);\n    resolveImpl = id => {\n      if (id) {\n        const client2 = resolveClientWithId(providedApolloClients, id);\n        if (client2) {\n          return client2;\n        }\n        return resolveClientWithId(savedCurrentClients, id);\n      }\n      const client = resolveDefaultClient(providedApolloClients, providedApolloClient);\n      if (client) {\n        return client;\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default);\n    };\n  }\n  function resolveClient(id = clientId) {\n    const client = resolveImpl(id);\n    if (!client) {\n      throw new Error(`Apollo client with id ${id != null ? id : \"default\"} not found. Use provideApolloClient() if you are outside of a component setup.`);\n    }\n    return client;\n  }\n  return {\n    resolveClient,\n    get client() {\n      return resolveClient();\n    }\n  };\n}\nvar currentApolloClients = {};\nfunction provideApolloClient(client) {\n  currentApolloClients = {\n    default: client\n  };\n  return function (fn) {\n    const result = fn();\n    currentApolloClients = {};\n    return result;\n  };\n}\nfunction provideApolloClients(clients) {\n  currentApolloClients = clients;\n  return function (fn) {\n    const result = fn();\n    currentApolloClients = {};\n    return result;\n  };\n}\n\n// src/util/paramToRef.ts\nimport { isRef, computed, ref } from \"vue-demi\";\nfunction paramToRef(param) {\n  if (isRef(param)) {\n    return param;\n  } else if (typeof param === \"function\") {\n    return computed(param);\n  } else {\n    return ref(param);\n  }\n}\n\n// src/util/paramToReactive.ts\nimport { isRef as isRef2, reactive, computed as computed2 } from \"vue-demi\";\nfunction paramToReactive(param) {\n  if (isRef2(param)) {\n    return param;\n  } else if (typeof param === \"function\") {\n    return computed2(param);\n  } else if (param) {\n    return reactive(param);\n  } else {\n    return param;\n  }\n}\n\n// src/util/useEventHook.ts\nfunction useEventHook() {\n  const fns = [];\n  function on(fn) {\n    fns.push(fn);\n    return {\n      off: () => off(fn)\n    };\n  }\n  function off(fn) {\n    const index = fns.indexOf(fn);\n    if (index !== -1) {\n      fns.splice(index, 1);\n    }\n  }\n  function trigger(param) {\n    for (const fn of fns) {\n      fn(param);\n    }\n  }\n  function getCount() {\n    return fns.length;\n  }\n  return {\n    on,\n    off,\n    trigger,\n    getCount\n  };\n}\n\n// src/util/loadingTracking.ts\nimport { watch, onUnmounted, ref as ref2, getCurrentInstance as getCurrentInstance2, onBeforeUnmount } from \"vue-demi\";\nfunction getAppTracking() {\n  var _a, _b, _c;\n  const vm = getCurrentInstance2();\n  const root = (_c = (_a = vm == null ? void 0 : vm.$root) != null ? _a : vm == null ? void 0 : vm.root) != null ? _c : (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$root;\n  if (!root) {\n    throw new Error(\"Instance $root not found\");\n  }\n  let appTracking;\n  if (!root._apolloAppTracking) {\n    appTracking = root._apolloAppTracking = {\n      queries: ref2(0),\n      mutations: ref2(0),\n      subscriptions: ref2(0),\n      components: new Map()\n    };\n  } else {\n    appTracking = root._apolloAppTracking;\n  }\n  return {\n    appTracking\n  };\n}\nfunction getCurrentTracking() {\n  const vm = getCurrentInstance2();\n  if (!vm) {\n    throw new Error(\"getCurrentTracking must be used during a component setup\");\n  }\n  const {\n    appTracking\n  } = getAppTracking();\n  let tracking;\n  if (!appTracking.components.has(vm)) {\n    appTracking.components.set(vm, tracking = {\n      queries: ref2(0),\n      mutations: ref2(0),\n      subscriptions: ref2(0)\n    });\n    onUnmounted(() => {\n      appTracking.components.delete(vm);\n    });\n  } else {\n    tracking = appTracking.components.get(vm);\n  }\n  return {\n    appTracking,\n    tracking\n  };\n}\nfunction track(loading, type) {\n  const {\n    appTracking,\n    tracking\n  } = getCurrentTracking();\n  watch(loading, (value, oldValue) => {\n    if (oldValue != null && value !== oldValue) {\n      const mod = value ? 1 : -1;\n      tracking[type].value += mod;\n      appTracking[type].value += mod;\n    }\n  }, {\n    immediate: true\n  });\n  onBeforeUnmount(() => {\n    if (loading.value) {\n      tracking[type].value--;\n      appTracking[type].value--;\n    }\n  });\n}\nfunction trackQuery(loading) {\n  track(loading, \"queries\");\n}\nfunction trackMutation(loading) {\n  track(loading, \"mutations\");\n}\nfunction trackSubscription(loading) {\n  track(loading, \"subscriptions\");\n}\n\n// src/util/toApolloError.ts\nimport { ApolloError, isApolloError } from \"@apollo/client/core/index.js\";\nfunction toApolloError(error) {\n  if (!(error instanceof Error)) {\n    return new ApolloError({\n      networkError: Object.assign(new Error(), {\n        originalError: error\n      }),\n      errorMessage: String(error)\n    });\n  }\n  if (isApolloError(error)) {\n    return error;\n  }\n  return new ApolloError({\n    networkError: error,\n    errorMessage: error.message\n  });\n}\nfunction resultErrorsToApolloError(errors) {\n  return new ApolloError({\n    graphQLErrors: errors,\n    errorMessage: `GraphQL response contains errors: ${errors.map(e => e.message).join(\" | \")}`\n  });\n}\n\n// src/util/env.ts\nvar isServer = typeof window === \"undefined\";\n\n// src/useQuery.ts\nfunction useQuery(document, variables, options) {\n  return useQueryImpl(document, variables, options);\n}\nfunction useQueryImpl(document, variables, options = {}, lazy = false) {\n  var _a;\n  const vm = getCurrentInstance3();\n  const currentOptions = ref3();\n  const documentRef = paramToRef(document);\n  const variablesRef = paramToRef(variables);\n  const optionsRef = paramToReactive(options);\n  const result = ref3();\n  const resultEvent = useEventHook();\n  const error = ref3(null);\n  const errorEvent = useEventHook();\n  const loading = ref3(false);\n  vm && trackQuery(loading);\n  const networkStatus = ref3();\n  let firstResolve;\n  let firstReject;\n  vm && ((_a = onServerPrefetch) == null ? void 0 : _a(() => {\n    var _a2;\n    if (!isEnabled.value || isServer && ((_a2 = currentOptions.value) == null ? void 0 : _a2.prefetch) === false) return;\n    return new Promise((resolve, reject) => {\n      firstResolve = () => {\n        resolve();\n        firstResolve = void 0;\n        firstReject = void 0;\n      };\n      firstReject = apolloError => {\n        reject(apolloError);\n        firstResolve = void 0;\n        firstReject = void 0;\n      };\n    }).finally(stop);\n  }));\n  const {\n    resolveClient\n  } = useApolloClient();\n  const query = ref3();\n  let observer;\n  let started = false;\n  let ignoreNextResult = false;\n  function start() {\n    var _a2, _b, _c, _d, _e;\n    if (started || !isEnabled.value || isServer && ((_a2 = currentOptions.value) == null ? void 0 : _a2.prefetch) === false) {\n      if (firstResolve) firstResolve();\n      return;\n    }\n    started = true;\n    error.value = null;\n    loading.value = true;\n    const client = resolveClient((_b = currentOptions.value) == null ? void 0 : _b.clientId);\n    query.value = client.watchQuery({\n      query: currentDocument,\n      variables: currentVariables,\n      ...currentOptions.value,\n      ...(isServer && ((_c = currentOptions.value) == null ? void 0 : _c.fetchPolicy) !== \"no-cache\" ? {\n        fetchPolicy: \"network-only\"\n      } : {})\n    });\n    startQuerySubscription();\n    if (!isServer && (((_d = currentOptions.value) == null ? void 0 : _d.fetchPolicy) !== \"no-cache\" || currentOptions.value.notifyOnNetworkStatusChange)) {\n      const currentResult = query.value.getCurrentResult(false);\n      if (!currentResult.loading || currentResult.partial || ((_e = currentOptions.value) == null ? void 0 : _e.notifyOnNetworkStatusChange)) {\n        onNextResult(currentResult);\n        ignoreNextResult = !currentResult.loading;\n      } else if (currentResult.error) {\n        onError(currentResult.error);\n        ignoreNextResult = true;\n      }\n    }\n    if (!isServer) {\n      for (const item of subscribeToMoreItems) {\n        addSubscribeToMore(item);\n      }\n    }\n  }\n  function startQuerySubscription() {\n    if (observer && !observer.closed) return;\n    if (!query.value) return;\n    ignoreNextResult = false;\n    observer = query.value.subscribe({\n      next: onNextResult,\n      error: onError\n    });\n  }\n  function onNextResult(queryResult) {\n    var _a2;\n    if (ignoreNextResult) {\n      ignoreNextResult = false;\n      return;\n    }\n    error.value = null;\n    processNextResult(queryResult);\n    if (!queryResult.error && ((_a2 = queryResult.errors) == null ? void 0 : _a2.length)) {\n      processError(resultErrorsToApolloError(queryResult.errors));\n    }\n    if (firstResolve) {\n      firstResolve();\n      stop();\n    }\n  }\n  function processNextResult(queryResult) {\n    result.value = queryResult.data && Object.keys(queryResult.data).length === 0 ? void 0 : queryResult.data;\n    loading.value = queryResult.loading;\n    networkStatus.value = queryResult.networkStatus;\n    resultEvent.trigger(queryResult);\n  }\n  function onError(queryError) {\n    var _a2, _b, _c, _d;\n    if (ignoreNextResult) {\n      ignoreNextResult = false;\n      return;\n    }\n    const apolloError = toApolloError(queryError);\n    const client = resolveClient((_a2 = currentOptions.value) == null ? void 0 : _a2.clientId);\n    const errorPolicy = ((_b = currentOptions.value) == null ? void 0 : _b.errorPolicy) || ((_d = (_c = client.defaultOptions) == null ? void 0 : _c.watchQuery) == null ? void 0 : _d.errorPolicy);\n    if (errorPolicy && errorPolicy !== \"none\") {\n      processNextResult(query.value.getCurrentResult());\n    }\n    processError(apolloError);\n    if (firstReject) {\n      firstReject(apolloError);\n      stop();\n    }\n    resubscribeToQuery();\n  }\n  function processError(apolloError) {\n    error.value = apolloError;\n    loading.value = false;\n    networkStatus.value = 8;\n    errorEvent.trigger(apolloError);\n  }\n  function resubscribeToQuery() {\n    if (!query.value) return;\n    const lastError = query.value.getLastError();\n    const lastResult = query.value.getLastResult();\n    query.value.resetLastResults();\n    startQuerySubscription();\n    Object.assign(query.value, {\n      lastError,\n      lastResult\n    });\n  }\n  let onStopHandlers = [];\n  function stop() {\n    if (firstResolve) firstResolve();\n    if (!started) return;\n    started = false;\n    loading.value = false;\n    onStopHandlers.forEach(handler => handler());\n    onStopHandlers = [];\n    if (query.value) {\n      query.value.stopPolling();\n      query.value = null;\n    }\n    if (observer) {\n      observer.unsubscribe();\n      observer = void 0;\n    }\n  }\n  let restarting = false;\n  function baseRestart() {\n    if (!started || restarting) return;\n    restarting = true;\n    nextTick(() => {\n      if (started) {\n        stop();\n        start();\n      }\n      restarting = false;\n    });\n  }\n  let debouncedRestart;\n  let isRestartDebounceSetup = false;\n  function updateRestartFn() {\n    var _a2, _b;\n    if (!currentOptions.value) {\n      debouncedRestart = baseRestart;\n    } else {\n      if ((_a2 = currentOptions.value) == null ? void 0 : _a2.throttle) {\n        debouncedRestart = throttle(currentOptions.value.throttle, baseRestart);\n      } else if ((_b = currentOptions.value) == null ? void 0 : _b.debounce) {\n        debouncedRestart = debounce(currentOptions.value.debounce, baseRestart);\n      } else {\n        debouncedRestart = baseRestart;\n      }\n      isRestartDebounceSetup = true;\n    }\n  }\n  function restart() {\n    if (!isRestartDebounceSetup) updateRestartFn();\n    debouncedRestart();\n  }\n  let currentDocument;\n  watch2(documentRef, value => {\n    currentDocument = value;\n    restart();\n  }, {\n    immediate: true\n  });\n  let currentVariables;\n  let currentVariablesSerialized;\n  watch2(variablesRef, (value, oldValue) => {\n    const serialized = JSON.stringify(value);\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value;\n      restart();\n    }\n    currentVariablesSerialized = serialized;\n  }, {\n    deep: true,\n    immediate: true\n  });\n  watch2(() => unref(optionsRef), value => {\n    if (currentOptions.value && (currentOptions.value.throttle !== value.throttle || currentOptions.value.debounce !== value.debounce)) {\n      updateRestartFn();\n    }\n    currentOptions.value = value;\n    restart();\n  }, {\n    deep: true,\n    immediate: true\n  });\n  function refetch(variables2 = void 0) {\n    if (query.value) {\n      if (variables2) {\n        currentVariables = variables2;\n      }\n      error.value = null;\n      loading.value = true;\n      return query.value.refetch(variables2).then(refetchResult => {\n        var _a2;\n        const currentResult = (_a2 = query.value) == null ? void 0 : _a2.getCurrentResult();\n        currentResult && processNextResult(currentResult);\n        return refetchResult;\n      });\n    }\n  }\n  function fetchMore(options2) {\n    if (query.value) {\n      error.value = null;\n      loading.value = true;\n      return query.value.fetchMore(options2).then(fetchMoreResult => {\n        var _a2;\n        const currentResult = (_a2 = query.value) == null ? void 0 : _a2.getCurrentResult();\n        currentResult && processNextResult(currentResult);\n        return fetchMoreResult;\n      });\n    }\n  }\n  const subscribeToMoreItems = [];\n  function subscribeToMore(options2) {\n    if (isServer) return;\n    const optionsRef2 = paramToRef(options2);\n    watch2(optionsRef2, (value, oldValue, onCleanup) => {\n      const index = subscribeToMoreItems.findIndex(item2 => item2.options === oldValue);\n      if (index !== -1) {\n        subscribeToMoreItems.splice(index, 1);\n      }\n      const item = {\n        options: value,\n        unsubscribeFns: []\n      };\n      subscribeToMoreItems.push(item);\n      addSubscribeToMore(item);\n      onCleanup(() => {\n        item.unsubscribeFns.forEach(fn => fn());\n        item.unsubscribeFns = [];\n      });\n    }, {\n      immediate: true\n    });\n  }\n  function addSubscribeToMore(item) {\n    if (!started) return;\n    if (!query.value) {\n      throw new Error(\"Query is not defined\");\n    }\n    const unsubscribe = query.value.subscribeToMore(item.options);\n    onStopHandlers.push(unsubscribe);\n    item.unsubscribeFns.push(unsubscribe);\n  }\n  const forceDisabled = ref3(lazy);\n  const enabledOption = computed3(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled);\n  const isEnabled = computed3(() => enabledOption.value && !forceDisabled.value);\n  watch2(isEnabled, value => {\n    if (value) {\n      start();\n    } else {\n      stop();\n    }\n  }, {\n    immediate: true\n  });\n  vm && onBeforeUnmount2(() => {\n    stop();\n    subscribeToMoreItems.length = 0;\n  });\n  return {\n    result,\n    loading,\n    networkStatus,\n    error,\n    start,\n    stop,\n    restart,\n    forceDisabled,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    query,\n    refetch,\n    fetchMore,\n    subscribeToMore,\n    onResult: resultEvent.on,\n    onError: errorEvent.on\n  };\n}\n\n// src/useLazyQuery.ts\nimport { isRef as isRef3 } from \"vue-demi\";\nfunction useLazyQuery(document, variables, options) {\n  const query = useQueryImpl(document, variables, options, true);\n  function load(document2, variables2, options2) {\n    if (document2) {\n      query.document.value = document2;\n    }\n    if (variables2) {\n      query.variables.value = variables2;\n    }\n    if (options2) {\n      Object.assign(isRef3(query.options) ? query.options.value : query.options, options2);\n    }\n    query.forceDisabled.value = false;\n  }\n  return {\n    ...query,\n    load\n  };\n}\n\n// src/useMutation.ts\nimport { ref as ref4, onBeforeUnmount as onBeforeUnmount3, isRef as isRef4, getCurrentInstance as getCurrentInstance4 } from \"vue-demi\";\nfunction useMutation(document, options = {}) {\n  const vm = getCurrentInstance4();\n  const loading = ref4(false);\n  vm && trackMutation(loading);\n  const error = ref4(null);\n  const called = ref4(false);\n  const doneEvent = useEventHook();\n  const errorEvent = useEventHook();\n  const {\n    resolveClient\n  } = useApolloClient();\n  async function mutate(variables, overrideOptions = {}) {\n    let currentDocument;\n    if (typeof document === \"function\") {\n      currentDocument = document();\n    } else if (isRef4(document)) {\n      currentDocument = document.value;\n    } else {\n      currentDocument = document;\n    }\n    let currentOptions;\n    if (typeof options === \"function\") {\n      currentOptions = options();\n    } else if (isRef4(options)) {\n      currentOptions = options.value;\n    } else {\n      currentOptions = options;\n    }\n    const client = resolveClient(currentOptions.clientId);\n    error.value = null;\n    loading.value = true;\n    called.value = true;\n    try {\n      const result = await client.mutate({\n        mutation: currentDocument,\n        ...currentOptions,\n        ...overrideOptions,\n        variables: (variables != null ? variables : currentOptions.variables) ? {\n          ...currentOptions.variables,\n          ...variables\n        } : void 0\n      });\n      loading.value = false;\n      doneEvent.trigger(result);\n      return result;\n    } catch (e) {\n      const apolloError = toApolloError(e);\n      error.value = apolloError;\n      loading.value = false;\n      errorEvent.trigger(apolloError);\n      if (currentOptions.throws === \"always\" || currentOptions.throws !== \"never\" && !errorEvent.getCount()) {\n        throw apolloError;\n      }\n    }\n    return null;\n  }\n  vm && onBeforeUnmount3(() => {\n    loading.value = false;\n  });\n  return {\n    mutate,\n    loading,\n    error,\n    called,\n    onDone: doneEvent.on,\n    onError: errorEvent.on\n  };\n}\n\n// src/useSubscription.ts\nimport { ref as ref5, watch as watch3, isRef as isRef5, computed as computed4, getCurrentInstance as getCurrentInstance5, onBeforeUnmount as onBeforeUnmount4, nextTick as nextTick2 } from \"vue-demi\";\nimport { throttle as throttle2, debounce as debounce2 } from \"throttle-debounce\";\nfunction useSubscription(document, variables = void 0, options = {}) {\n  const vm = getCurrentInstance5();\n  const documentRef = paramToRef(document);\n  const variablesRef = paramToRef(variables);\n  const optionsRef = paramToReactive(options);\n  const result = ref5();\n  const resultEvent = useEventHook();\n  const error = ref5(null);\n  const errorEvent = useEventHook();\n  const loading = ref5(false);\n  vm && trackSubscription(loading);\n  const {\n    resolveClient\n  } = useApolloClient();\n  const subscription = ref5(null);\n  let observer = null;\n  let started = false;\n  function start() {\n    var _a;\n    if (started || !isEnabled.value || isServer) return;\n    started = true;\n    loading.value = true;\n    const client = resolveClient((_a = currentOptions.value) == null ? void 0 : _a.clientId);\n    subscription.value = client.subscribe({\n      query: currentDocument,\n      variables: currentVariables,\n      ...currentOptions.value\n    });\n    observer = subscription.value.subscribe({\n      next: onNextResult,\n      error: onError\n    });\n  }\n  function onNextResult(fetchResult) {\n    result.value = fetchResult.data;\n    loading.value = false;\n    resultEvent.trigger(fetchResult);\n  }\n  function onError(fetchError) {\n    const apolloError = toApolloError(fetchError);\n    error.value = apolloError;\n    loading.value = false;\n    errorEvent.trigger(apolloError);\n  }\n  function stop() {\n    if (!started) return;\n    started = false;\n    loading.value = false;\n    if (subscription.value) {\n      subscription.value = null;\n    }\n    if (observer) {\n      observer.unsubscribe();\n      observer = null;\n    }\n  }\n  let restarting = false;\n  function baseRestart() {\n    if (!started || restarting) return;\n    restarting = true;\n    nextTick2(() => {\n      if (started) {\n        stop();\n        start();\n      }\n      restarting = false;\n    });\n  }\n  let debouncedRestart;\n  function updateRestartFn() {\n    var _a, _b;\n    if ((_a = currentOptions.value) == null ? void 0 : _a.throttle) {\n      debouncedRestart = throttle2(currentOptions.value.throttle, baseRestart);\n    } else if ((_b = currentOptions.value) == null ? void 0 : _b.debounce) {\n      debouncedRestart = debounce2(currentOptions.value.debounce, baseRestart);\n    } else {\n      debouncedRestart = baseRestart;\n    }\n  }\n  function restart() {\n    if (!debouncedRestart) updateRestartFn();\n    debouncedRestart();\n  }\n  const currentOptions = ref5();\n  watch3(() => isRef5(optionsRef) ? optionsRef.value : optionsRef, value => {\n    if (currentOptions.value && (currentOptions.value.throttle !== value.throttle || currentOptions.value.debounce !== value.debounce)) {\n      updateRestartFn();\n    }\n    currentOptions.value = value;\n    restart();\n  }, {\n    deep: true,\n    immediate: true\n  });\n  let currentDocument;\n  watch3(documentRef, value => {\n    currentDocument = value;\n    restart();\n  }, {\n    immediate: true\n  });\n  let currentVariables;\n  let currentVariablesSerialized;\n  watch3(variablesRef, (value, oldValue) => {\n    const serialized = JSON.stringify(value);\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value;\n      restart();\n    }\n    currentVariablesSerialized = serialized;\n  }, {\n    deep: true,\n    immediate: true\n  });\n  const enabledOption = computed4(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled);\n  const isEnabled = enabledOption;\n  watch3(isEnabled, value => {\n    if (value) {\n      start();\n    } else {\n      stop();\n    }\n  }, {\n    immediate: true\n  });\n  vm && onBeforeUnmount4(stop);\n  return {\n    result,\n    loading,\n    error,\n    start,\n    stop,\n    restart,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    subscription,\n    onResult: resultEvent.on,\n    onError: errorEvent.on\n  };\n}\n\n// src/useResult.ts\nimport { computed as computed5 } from \"vue-demi\";\nfunction useResult(result, defaultValue, pick) {\n  console.warn(`'useResult' is deprecated and will be removed soon. Please use 'computed' instead.\nBefore:\nconst items = useResult(result, [], data => data.someField.myItems)\nAfter:\nconst items = computed(() => result.value?.someField.myItems ?? [])`);\n  return computed5(() => {\n    const value = result.value;\n    if (value) {\n      if (pick) {\n        try {\n          return pick(value);\n        } catch (e) {}\n      } else {\n        const keys = Object.keys(value);\n        if (keys.length === 1) {\n          return value[keys[0]];\n        } else {\n          return value;\n        }\n      }\n    }\n    return defaultValue;\n  });\n}\n\n// src/useLoading.ts\nimport { computed as computed6 } from \"vue-demi\";\nfunction useQueryLoading() {\n  const {\n    tracking\n  } = getCurrentTracking();\n  return computed6(() => tracking.queries.value > 0);\n}\nfunction useMutationLoading() {\n  const {\n    tracking\n  } = getCurrentTracking();\n  return computed6(() => tracking.mutations.value > 0);\n}\nfunction useSubscriptionLoading() {\n  const {\n    tracking\n  } = getCurrentTracking();\n  return computed6(() => tracking.subscriptions.value > 0);\n}\nfunction useGlobalQueryLoading() {\n  const {\n    appTracking\n  } = getAppTracking();\n  return computed6(() => appTracking.queries.value > 0);\n}\nfunction useGlobalMutationLoading() {\n  const {\n    appTracking\n  } = getAppTracking();\n  return computed6(() => appTracking.mutations.value > 0);\n}\nfunction useGlobalSubscriptionLoading() {\n  const {\n    appTracking\n  } = getAppTracking();\n  return computed6(() => appTracking.subscriptions.value > 0);\n}\nexport { ApolloClients, DefaultApolloClient, provideApolloClient, provideApolloClients, useApolloClient, useGlobalMutationLoading, useGlobalQueryLoading, useGlobalSubscriptionLoading, useLazyQuery, useMutation, useMutationLoading, useQuery, useQueryLoading, useResult, useSubscription, useSubscriptionLoading };","map":{"version":3,"names":["ref","ref3","unref","computed","computed3","watch","watch2","onServerPrefetch","getCurrentInstance","getCurrentInstance3","onBeforeUnmount","onBeforeUnmount2","nextTick","throttle","debounce","inject","DefaultApolloClient","Symbol","ApolloClients","resolveDefaultClient","providedApolloClients","providedApolloClient","resolvedClient","default","resolveClientWithId","clientId","Error","useApolloClient","resolveImpl","savedCurrentClients","currentApolloClients","id","client2","client","resolveClient","provideApolloClient","fn","result","provideApolloClients","clients","isRef","paramToRef","param","isRef2","reactive","computed2","paramToReactive","useEventHook","fns","on","push","off","index","indexOf","splice","trigger","getCount","length","onUnmounted","ref2","getCurrentInstance2","getAppTracking","_a","_b","_c","vm","root","$root","proxy","appTracking","_apolloAppTracking","queries","mutations","subscriptions","components","Map","getCurrentTracking","tracking","has","set","delete","get","track","loading","type","value","oldValue","mod","immediate","trackQuery","trackMutation","trackSubscription","ApolloError","isApolloError","toApolloError","error","networkError","Object","assign","originalError","errorMessage","String","message","resultErrorsToApolloError","errors","graphQLErrors","map","e","join","isServer","window","useQuery","document","variables","options","useQueryImpl","lazy","currentOptions","documentRef","variablesRef","optionsRef","resultEvent","errorEvent","networkStatus","firstResolve","firstReject","_a2","isEnabled","prefetch","Promise","resolve","reject","apolloError","finally","stop","query","observer","started","ignoreNextResult","start","_d","_e","watchQuery","currentDocument","currentVariables","fetchPolicy","startQuerySubscription","notifyOnNetworkStatusChange","currentResult","getCurrentResult","partial","onNextResult","onError","item","subscribeToMoreItems","addSubscribeToMore","closed","subscribe","next","queryResult","processNextResult","processError","data","keys","queryError","errorPolicy","defaultOptions","resubscribeToQuery","lastError","getLastError","lastResult","getLastResult","resetLastResults","onStopHandlers","forEach","handler","stopPolling","unsubscribe","restarting","baseRestart","debouncedRestart","isRestartDebounceSetup","updateRestartFn","restart","currentVariablesSerialized","serialized","JSON","stringify","deep","refetch","variables2","then","refetchResult","fetchMore","options2","fetchMoreResult","subscribeToMore","optionsRef2","onCleanup","findIndex","item2","unsubscribeFns","forceDisabled","enabledOption","enabled","onResult","isRef3","useLazyQuery","load","document2","ref4","onBeforeUnmount3","isRef4","getCurrentInstance4","useMutation","called","doneEvent","mutate","overrideOptions","mutation","throws","onDone","ref5","watch3","isRef5","computed4","getCurrentInstance5","onBeforeUnmount4","nextTick2","throttle2","debounce2","useSubscription","subscription","fetchResult","fetchError","computed5","useResult","defaultValue","pick","console","warn","computed6","useQueryLoading","useMutationLoading","useSubscriptionLoading","useGlobalQueryLoading","useGlobalMutationLoading","useGlobalSubscriptionLoading"],"sources":["../src/useQuery.ts","../src/useApolloClient.ts","../src/util/paramToRef.ts","../src/util/paramToReactive.ts","../src/util/useEventHook.ts","../src/util/loadingTracking.ts","../src/util/toApolloError.ts","../src/util/env.ts","../src/useLazyQuery.ts","../src/useMutation.ts","../src/useSubscription.ts","../src/useResult.ts","../src/useLoading.ts"],"sourcesContent":["import {\n  ref,\n  Ref,\n  unref,\n  computed,\n  watch,\n  onServerPrefetch,\n  getCurrentInstance,\n  onBeforeUnmount,\n  nextTick,\n} from 'vue-demi'\nimport { DocumentNode } from 'graphql'\nimport type {\n  OperationVariables,\n  WatchQueryOptions,\n  ObservableQuery,\n  ApolloQueryResult,\n  SubscribeToMoreOptions,\n  FetchMoreQueryOptions,\n  FetchMoreOptions,\n  ObservableSubscription,\n  TypedDocumentNode,\n  ApolloError,\n} from '@apollo/client/core/index.js'\nimport { throttle, debounce } from 'throttle-debounce'\nimport { useApolloClient } from './useApolloClient'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { paramToRef } from './util/paramToRef'\nimport { paramToReactive } from './util/paramToReactive'\nimport { useEventHook } from './util/useEventHook'\nimport { trackQuery } from './util/loadingTracking'\nimport { resultErrorsToApolloError, toApolloError } from './util/toApolloError'\nimport { isServer } from './util/env'\n\nimport type { CurrentInstance } from './util/types'\n\nexport interface UseQueryOptions<\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TResult = any,\n  TVariables = OperationVariables\n  // @ts-expect-error apollo-client types issue with TVariables\n> extends Omit<WatchQueryOptions<TVariables>, 'query' | 'variables'> {\n  clientId?: string\n  enabled?: boolean\n  throttle?: number\n  debounce?: number\n  prefetch?: boolean\n}\n\ninterface SubscribeToMoreItem {\n  options: any\n  unsubscribeFns: (() => void)[]\n}\n\n// Parameters\nexport type DocumentParameter<TResult, TVariables = undefined> = DocumentNode | Ref<DocumentNode> | ReactiveFunction<DocumentNode> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables>> | ReactiveFunction<TypedDocumentNode<TResult, TVariables>>\nexport type VariablesParameter<TVariables> = TVariables | Ref<TVariables> | ReactiveFunction<TVariables>\nexport type OptionsParameter<TResult, TVariables> = UseQueryOptions<TResult, TVariables> | Ref<UseQueryOptions<TResult, TVariables>> | ReactiveFunction<UseQueryOptions<TResult, TVariables>>\n\n// Return\nexport interface UseQueryReturn<TResult, TVariables> {\n  result: Ref<TResult | undefined>\n  loading: Ref<boolean>\n  networkStatus: Ref<number | undefined>\n  error: Ref<ApolloError | null>\n  start: () => void\n  stop: () => void\n  restart: () => void\n  forceDisabled: Ref<boolean>\n  document: Ref<DocumentNode>\n  variables: Ref<TVariables | undefined>\n  options: UseQueryOptions<TResult, TVariables> | Ref<UseQueryOptions<TResult, TVariables>>\n  // @ts-expect-error apollo-client types issue with TVariables\n  query: Ref<ObservableQuery<TResult, TVariables> | null | undefined>\n  refetch: (variables?: TVariables) => Promise<ApolloQueryResult<TResult>> | undefined\n  fetchMore: (options: FetchMoreQueryOptions<TVariables, TResult> & FetchMoreOptions<TResult, TVariables>) => Promise<ApolloQueryResult<TResult>> | undefined\n  subscribeToMore: <TSubscriptionVariables = OperationVariables, TSubscriptionData = TResult>(options: SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData> | Ref<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>> | ReactiveFunction<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>>) => void\n  onResult: (fn: (param: ApolloQueryResult<TResult>) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError) => void) => {\n    off: () => void\n  }\n}\n\n/**\n * Use a query that does not require variables or options.\n * */\nexport function useQuery<TResult = any> (\n  document: DocumentParameter<TResult, undefined>\n): UseQueryReturn<TResult, undefined>\n\n/**\n * Use a query that has optional variables but not options\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>\n): UseQueryReturn<TResult, TVariables>\n\n/**\n * Use a query that has required variables but not options\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>\n): UseQueryReturn<TResult, TVariables>\n\n/**\n * Use a query that requires options but not variables.\n */\nexport function useQuery<TResult = any> (\n  document: DocumentParameter<TResult, undefined>,\n  variables: undefined | null,\n  options: OptionsParameter<TResult, null>,\n): UseQueryReturn<TResult, null>\n\n/**\n * Use a query that requires variables and options.\n */\nexport function useQuery<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables>,\n): UseQueryReturn<TResult, TVariables>\n\nexport function useQuery<\n  TResult,\n  TVariables extends OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options?: OptionsParameter<TResult, TVariables>,\n): UseQueryReturn<TResult, TVariables> {\n  return useQueryImpl<TResult, TVariables>(document, variables, options)\n}\n\nexport function useQueryImpl<\n  TResult,\n  TVariables extends OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables> = {},\n  lazy = false,\n): UseQueryReturn<TResult, TVariables> {\n  // Is on server?\n  const vm = getCurrentInstance() as CurrentInstance | null\n\n  const currentOptions = ref<UseQueryOptions<TResult, TVariables>>()\n\n  const documentRef = paramToRef(document)\n  const variablesRef = paramToRef(variables)\n  const optionsRef = paramToReactive(options)\n\n  // Result\n  /**\n   * Result from the query\n   */\n  const result = ref<TResult | undefined>()\n  const resultEvent = useEventHook<ApolloQueryResult<TResult>>()\n  const error = ref<ApolloError | null>(null)\n  const errorEvent = useEventHook<ApolloError>()\n\n  // Loading\n\n  /**\n   * Indicates if a network request is pending\n   */\n  const loading = ref(false)\n  vm && trackQuery(loading)\n  const networkStatus = ref<number>()\n\n  // SSR\n  let firstResolve: (() => void) | undefined\n  let firstReject: ((apolloError: ApolloError) => void) | undefined\n  vm && onServerPrefetch?.(() => {\n    if (!isEnabled.value || (isServer && currentOptions.value?.prefetch === false)) return\n\n    return new Promise<void>((resolve, reject) => {\n      firstResolve = () => {\n        resolve()\n        firstResolve = undefined\n        firstReject = undefined\n      }\n      firstReject = (apolloError: ApolloError) => {\n        reject(apolloError)\n        firstResolve = undefined\n        firstReject = undefined\n      }\n    }).finally(stop)\n  })\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  // Query\n\n  const query: Ref<ObservableQuery<TResult, TVariables> | null | undefined> = ref()\n  let observer: ObservableSubscription | undefined\n  let started = false\n  let ignoreNextResult = false\n\n  /**\n   * Starts watching the query\n   */\n  function start () {\n    if (\n      started || !isEnabled.value ||\n      (isServer && currentOptions.value?.prefetch === false)\n    ) {\n      if (firstResolve) firstResolve()\n      return\n    }\n\n    started = true\n    error.value = null\n    loading.value = true\n\n    const client = resolveClient(currentOptions.value?.clientId)\n\n    query.value = client.watchQuery<TResult, TVariables>({\n      query: currentDocument,\n      variables: currentVariables,\n      ...currentOptions.value,\n      ...(isServer && currentOptions.value?.fetchPolicy !== 'no-cache')\n        ? {\n          fetchPolicy: 'network-only',\n        }\n        : {},\n    })\n\n    startQuerySubscription()\n\n    // Make the cache data available to the component immediately\n    // This prevents SSR hydration mismatches\n    if (!isServer && (currentOptions.value?.fetchPolicy !== 'no-cache' || currentOptions.value.notifyOnNetworkStatusChange)) {\n      const currentResult = query.value.getCurrentResult(false)\n\n      if (!currentResult.loading || currentResult.partial || currentOptions.value?.notifyOnNetworkStatusChange) {\n        onNextResult(currentResult)\n        ignoreNextResult = !currentResult.loading\n      } else if (currentResult.error) {\n        onError(currentResult.error)\n        ignoreNextResult = true\n      }\n    }\n\n    if (!isServer) {\n      for (const item of subscribeToMoreItems) {\n        addSubscribeToMore(item)\n      }\n    }\n  }\n\n  function startQuerySubscription () {\n    if (observer && !observer.closed) return\n    if (!query.value) return\n\n    // Create subscription\n    ignoreNextResult = false\n    observer = query.value.subscribe({\n      next: onNextResult,\n      error: onError,\n    })\n  }\n\n  function onNextResult (queryResult: ApolloQueryResult<TResult>) {\n    if (ignoreNextResult) {\n      ignoreNextResult = false\n      return\n    }\n\n    // Remove any previous error that may still be present from the last fetch (so result handlers\n    // don't receive old errors that may not even be applicable anymore).\n    error.value = null\n\n    processNextResult(queryResult)\n\n    // When `errorPolicy` is `all`, `onError` will not get called and\n    // ApolloQueryResult.errors may be set at the same time as we get a result\n    if (!queryResult.error && queryResult.errors?.length) {\n      processError(resultErrorsToApolloError(queryResult.errors))\n    }\n\n    if (firstResolve) {\n      firstResolve()\n      stop()\n    }\n  }\n\n  function processNextResult (queryResult: ApolloQueryResult<TResult>) {\n    result.value = queryResult.data && Object.keys(queryResult.data).length === 0 ? undefined : queryResult.data\n    loading.value = queryResult.loading\n    networkStatus.value = queryResult.networkStatus\n    resultEvent.trigger(queryResult)\n  }\n\n  function onError (queryError: unknown) {\n    if (ignoreNextResult) {\n      ignoreNextResult = false\n      return\n    }\n\n    // any error should already be an ApolloError, but we make sure\n    const apolloError = toApolloError(queryError)\n    const client = resolveClient(currentOptions.value?.clientId)\n    const errorPolicy = currentOptions.value?.errorPolicy || client.defaultOptions?.watchQuery?.errorPolicy\n\n    if (errorPolicy && errorPolicy !== 'none') {\n      processNextResult((query.value as ObservableQuery<TResult, TVariables>).getCurrentResult())\n    }\n    processError(apolloError)\n    if (firstReject) {\n      firstReject(apolloError)\n      stop()\n    }\n    // The observable closes the sub if an error occurs\n    resubscribeToQuery()\n  }\n\n  function processError (apolloError: ApolloError) {\n    error.value = apolloError\n    loading.value = false\n    networkStatus.value = 8\n    errorEvent.trigger(apolloError)\n  }\n\n  function resubscribeToQuery () {\n    if (!query.value) return\n    const lastError = query.value.getLastError()\n    const lastResult = query.value.getLastResult()\n    query.value.resetLastResults()\n    startQuerySubscription()\n    Object.assign(query.value, { lastError, lastResult })\n  }\n\n  let onStopHandlers: Array<() => void> = []\n\n  /**\n   * Stop watching the query\n   */\n  function stop () {\n    if (firstResolve) firstResolve()\n    if (!started) return\n    started = false\n    loading.value = false\n\n    onStopHandlers.forEach(handler => handler())\n    onStopHandlers = []\n\n    if (query.value) {\n      query.value.stopPolling()\n      query.value = null\n    }\n\n    if (observer) {\n      observer.unsubscribe()\n      observer = undefined\n    }\n  }\n\n  // Restart\n  let restarting = false\n  /**\n   * Queue a restart of the query (on next tick) if it is already active\n   */\n  function baseRestart () {\n    if (!started || restarting) return\n    restarting = true\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    nextTick(() => {\n      if (started) {\n        stop()\n        start()\n      }\n      restarting = false\n    })\n  }\n\n  let debouncedRestart: typeof baseRestart\n  let isRestartDebounceSetup = false\n  function updateRestartFn () {\n    // On server, will be called before currentOptions is initialized\n    // @TODO investigate\n    if (!currentOptions.value) {\n      debouncedRestart = baseRestart\n    } else {\n      if (currentOptions.value?.throttle) {\n        debouncedRestart = throttle(currentOptions.value.throttle, baseRestart)\n      } else if (currentOptions.value?.debounce) {\n        debouncedRestart = debounce(currentOptions.value.debounce, baseRestart)\n      } else {\n        debouncedRestart = baseRestart\n      }\n      isRestartDebounceSetup = true\n    }\n  }\n\n  function restart () {\n    if (!isRestartDebounceSetup) updateRestartFn()\n    debouncedRestart()\n  }\n\n  // Applying document\n  let currentDocument: DocumentNode\n  watch(documentRef, value => {\n    currentDocument = value\n    restart()\n  }, {\n    immediate: true,\n  })\n\n  // Applying variables\n  let currentVariables: TVariables | undefined\n  let currentVariablesSerialized: string\n  watch(variablesRef, (value, oldValue) => {\n    const serialized = JSON.stringify(value)\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value\n      restart()\n    }\n    currentVariablesSerialized = serialized\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Applying options\n  watch(() => unref(optionsRef), value => {\n    if (currentOptions.value && (\n      currentOptions.value.throttle !== value.throttle ||\n      currentOptions.value.debounce !== value.debounce\n    )) {\n      updateRestartFn()\n    }\n    currentOptions.value = value\n    restart()\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Refetch\n\n  function refetch (variables: TVariables | undefined = undefined) {\n    if (query.value) {\n      if (variables) {\n        currentVariables = variables\n      }\n      error.value = null\n      loading.value = true\n      return query.value.refetch(variables)\n        .then((refetchResult) => {\n          const currentResult = query.value?.getCurrentResult()\n          currentResult && processNextResult(currentResult)\n          return refetchResult\n        })\n    }\n  }\n\n  // Fetch more\n\n  function fetchMore (options: FetchMoreQueryOptions<TVariables, TResult> & FetchMoreOptions<TResult, TVariables>) {\n    if (query.value) {\n      error.value = null\n      loading.value = true\n      return query.value.fetchMore(options)\n        .then((fetchMoreResult) => {\n          const currentResult = query.value?.getCurrentResult()\n          currentResult && processNextResult(currentResult)\n          return fetchMoreResult\n        })\n    }\n  }\n\n  // Subscribe to more\n\n  const subscribeToMoreItems: SubscribeToMoreItem[] = []\n\n  function subscribeToMore<\n    TSubscriptionVariables = OperationVariables,\n    TSubscriptionData = TResult\n  > (\n    options: SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData> |\n    Ref<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>> |\n    ReactiveFunction<SubscribeToMoreOptions<TResult, TSubscriptionVariables, TSubscriptionData>>,\n  ) {\n    if (isServer) return\n    const optionsRef = paramToRef(options)\n    watch(optionsRef, (value, oldValue, onCleanup) => {\n      const index = subscribeToMoreItems.findIndex(item => item.options === oldValue)\n      if (index !== -1) {\n        subscribeToMoreItems.splice(index, 1)\n      }\n      const item: SubscribeToMoreItem = {\n        options: value,\n        unsubscribeFns: [],\n      }\n      subscribeToMoreItems.push(item)\n\n      addSubscribeToMore(item)\n\n      onCleanup(() => {\n        item.unsubscribeFns.forEach(fn => fn())\n        item.unsubscribeFns = []\n      })\n    }, {\n      immediate: true,\n    })\n  }\n\n  function addSubscribeToMore (item: SubscribeToMoreItem) {\n    if (!started) return\n    if (!query.value) {\n      throw new Error('Query is not defined')\n    }\n    const unsubscribe = query.value.subscribeToMore(item.options)\n    onStopHandlers.push(unsubscribe)\n    item.unsubscribeFns.push(unsubscribe)\n  }\n\n  // Enabled state\n\n  const forceDisabled = ref(lazy)\n  const enabledOption = computed(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled)\n  const isEnabled = computed(() => enabledOption.value && !forceDisabled.value)\n\n  // Auto start & stop\n  watch(isEnabled, value => {\n    if (value) {\n      start()\n    } else {\n      stop()\n    }\n  }, {\n    immediate: true,\n  })\n\n  // Teardown\n  vm && onBeforeUnmount(() => {\n    stop()\n    subscribeToMoreItems.length = 0\n  })\n\n  return {\n    result,\n    loading,\n    networkStatus,\n    error,\n    start,\n    stop,\n    restart,\n    forceDisabled,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    query,\n    refetch,\n    fetchMore,\n    subscribeToMore,\n    onResult: resultEvent.on,\n    onError: errorEvent.on,\n  }\n}\n","import { getCurrentInstance, inject } from 'vue-demi'\nimport { ApolloClient } from '@apollo/client/core/index.js'\n\nexport const DefaultApolloClient = Symbol('default-apollo-client')\nexport const ApolloClients = Symbol('apollo-clients')\n\ntype ClientId = string\ntype ClientDict<T> = Record<ClientId, ApolloClient<T>>\n\ntype ResolveClient<TCacheShape, TReturn = ApolloClient<TCacheShape>> = (clientId?: ClientId) => TReturn\ntype NullableApolloClient<TCacheShape> = ApolloClient<TCacheShape> | undefined\n\nexport interface UseApolloClientReturn<TCacheShape> {\n  resolveClient: ResolveClient<TCacheShape>\n  readonly client: ApolloClient<TCacheShape>\n}\n\nfunction resolveDefaultClient<T> (providedApolloClients: ClientDict<T> | null, providedApolloClient: ApolloClient<T> | null): NullableApolloClient<T> {\n  const resolvedClient = providedApolloClients\n    ? providedApolloClients.default\n    : (providedApolloClient ?? undefined)\n  return resolvedClient\n}\n\nfunction resolveClientWithId<T> (providedApolloClients: ClientDict<T> | null, clientId: ClientId): NullableApolloClient<T> {\n  if (!providedApolloClients) {\n    throw new Error(`No apolloClients injection found, tried to resolve '${clientId}' clientId`)\n  }\n  return providedApolloClients[clientId]\n}\n\nexport function useApolloClient<TCacheShape = any> (clientId?: ClientId): UseApolloClientReturn<TCacheShape> {\n  let resolveImpl: ResolveClient<TCacheShape, NullableApolloClient<TCacheShape>>\n\n  // Save current client in current closure scope\n  const savedCurrentClients = currentApolloClients\n\n  if (!getCurrentInstance()) {\n    resolveImpl = (id?: ClientId) => {\n      if (id) {\n        return resolveClientWithId(savedCurrentClients, id)\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default)\n    }\n  } else {\n    const providedApolloClients: ClientDict<TCacheShape> | null = inject(ApolloClients, null)\n    const providedApolloClient: ApolloClient<TCacheShape> | null = inject(DefaultApolloClient, null)\n\n    resolveImpl = (id?: ClientId) => {\n      if (id) {\n        const client = resolveClientWithId(providedApolloClients, id)\n        if (client) {\n          return client\n        }\n        return resolveClientWithId(savedCurrentClients, id)\n      }\n      const client = resolveDefaultClient(providedApolloClients, providedApolloClient)\n      if (client) {\n        return client\n      }\n      return resolveDefaultClient(savedCurrentClients, savedCurrentClients.default)\n    }\n  }\n\n  function resolveClient (id: ClientId | undefined = clientId) {\n    const client = resolveImpl(id)\n    if (!client) {\n      throw new Error(\n        `Apollo client with id ${\n          id ?? 'default'\n        } not found. Use provideApolloClient() if you are outside of a component setup.`,\n      )\n    }\n    return client\n  }\n\n  return {\n    resolveClient,\n    get client () {\n      return resolveClient()\n    },\n  }\n}\n\nlet currentApolloClients: ClientDict<any> = {}\n\nexport function provideApolloClient<TCacheShape = any> (client: ApolloClient<TCacheShape>) {\n  currentApolloClients = {\n    default: client,\n  }\n  return function <TFnResult = any> (fn: () => TFnResult) {\n    const result = fn()\n    currentApolloClients = {}\n    return result\n  }\n}\n\nexport function provideApolloClients<TCacheShape = any> (clients: ClientDict<TCacheShape>) {\n  currentApolloClients = clients\n  return function <TFnResult = any> (fn: () => TFnResult) {\n    const result = fn()\n    currentApolloClients = {}\n    return result\n  }\n}\n","import { Ref, isRef, computed, ref } from 'vue-demi'\nimport { ReactiveFunction } from './ReactiveFunction'\n\nexport function paramToRef<T> (param: T | Ref<T> | ReactiveFunction<T>): Ref<T> {\n  if (isRef(param)) {\n    return param\n  } else if (typeof param === 'function') {\n    return computed(param as ReactiveFunction<T>)\n  } else {\n    return ref(param) as Ref<T>\n  }\n}\n","import { Ref, isRef, reactive, computed } from 'vue-demi'\nimport { ReactiveFunction } from './ReactiveFunction'\n\n// eslint-disable-next-line @typescript-eslint/ban-types\ntype TObject = object\n\nexport function paramToReactive<T extends TObject> (param: T | Ref<T> | ReactiveFunction<T>): T | Ref<T> {\n  if (isRef(param)) {\n    return param\n  } else if (typeof param === 'function') {\n    return computed(param as ReactiveFunction<T>)\n  } else if (param) {\n    return reactive(param) as T\n  } else {\n    return param\n  }\n}\n","export function useEventHook<TParam = any> () {\n  const fns: Array<(param: TParam) => void> = []\n\n  function on (fn: (param: TParam) => void) {\n    fns.push(fn)\n    return {\n      off: () => off(fn),\n    }\n  }\n\n  function off (fn: (param: TParam) => void) {\n    const index = fns.indexOf(fn)\n    if (index !== -1) {\n      fns.splice(index, 1)\n    }\n  }\n\n  function trigger (param: TParam) {\n    for (const fn of fns) {\n      fn(param)\n    }\n  }\n\n  function getCount () {\n    return fns.length\n  }\n\n  return {\n    on,\n    off,\n    trigger,\n    getCount,\n  }\n}\n","import { Ref, watch, onUnmounted, ref, getCurrentInstance, onBeforeUnmount } from 'vue-demi'\nimport type { CurrentInstance } from './types'\n\nexport interface LoadingTracking {\n  queries: Ref<number>\n  mutations: Ref<number>\n  subscriptions: Ref<number>\n}\n\nexport interface AppLoadingTracking extends LoadingTracking {\n  components: Map<any, LoadingTracking>\n}\n\nexport function getAppTracking () {\n  const vm = getCurrentInstance() as CurrentInstance | null\n  const root = vm?.$root ?? vm?.root ?? vm?.proxy?.$root as CurrentInstance | null | undefined\n  if (!root) {\n    throw new Error('Instance $root not found')\n  }\n\n  let appTracking: AppLoadingTracking\n\n  if (!root._apolloAppTracking) {\n    // Add per Vue tracking\n    appTracking = root._apolloAppTracking = {\n      queries: ref(0),\n      mutations: ref(0),\n      subscriptions: ref(0),\n      components: new Map(),\n    }\n  } else {\n    appTracking = root._apolloAppTracking\n  }\n\n  return {\n    appTracking,\n  }\n}\n\nexport function getCurrentTracking () {\n  const vm = getCurrentInstance()\n  if (!vm) {\n    throw new Error('getCurrentTracking must be used during a component setup')\n  }\n\n  const { appTracking } = getAppTracking()\n\n  let tracking: LoadingTracking\n\n  if (!appTracking.components.has(vm)) {\n    // Add per-component tracking\n    appTracking.components.set(vm, tracking = {\n      queries: ref(0),\n      mutations: ref(0),\n      subscriptions: ref(0),\n    })\n    // Cleanup\n    onUnmounted(() => {\n      appTracking.components.delete(vm)\n    })\n  } else {\n    tracking = appTracking.components.get(vm) as LoadingTracking\n  }\n\n  return {\n    appTracking,\n    tracking,\n  }\n}\n\nfunction track (loading: Ref<boolean>, type: keyof LoadingTracking) {\n  const { appTracking, tracking } = getCurrentTracking()\n\n  watch(loading, (value, oldValue) => {\n    if (oldValue != null && value !== oldValue) {\n      const mod = value ? 1 : -1\n      tracking[type].value += mod\n      appTracking[type].value += mod\n    }\n  }, {\n    immediate: true,\n  })\n\n  onBeforeUnmount(() => {\n    if (loading.value) {\n      tracking[type].value--\n      appTracking[type].value--\n    }\n  })\n}\n\nexport function trackQuery (loading: Ref<boolean>) {\n  track(loading, 'queries')\n}\n\nexport function trackMutation (loading: Ref<boolean>) {\n  track(loading, 'mutations')\n}\n\nexport function trackSubscription (loading: Ref<boolean>) {\n  track(loading, 'subscriptions')\n}\n","import { ApolloError, isApolloError } from '@apollo/client/core/index.js'\nimport { GraphQLErrors } from '@apollo/client/errors/index.js'\n\nexport function toApolloError (error: unknown): ApolloError {\n  if (!(error instanceof Error)) {\n    return new ApolloError({\n      networkError: Object.assign(new Error(), { originalError: error }),\n      errorMessage: String(error),\n    })\n  }\n\n  if (isApolloError(error)) {\n    return error\n  }\n\n  return new ApolloError({ networkError: error, errorMessage: error.message })\n}\n\nexport function resultErrorsToApolloError (errors: GraphQLErrors): ApolloError {\n  return new ApolloError({\n    graphQLErrors: errors,\n    errorMessage: `GraphQL response contains errors: ${errors.map((e: any) => e.message).join(' | ')}`,\n  })\n}\n","export const isServer = typeof window === 'undefined'\n","import { DocumentNode } from 'graphql'\nimport { isRef } from 'vue-demi'\nimport { useQueryImpl, DocumentParameter, VariablesParameter, OptionsParameter, UseQueryOptions } from './useQuery'\n\nexport function useLazyQuery<\n  TResult = any,\n  TVariables = any,\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables?: VariablesParameter<TVariables>,\n  options?: OptionsParameter<TResult, TVariables>,\n) {\n  // @ts-expect-error apollo-client types issue with TVariables\n  const query = useQueryImpl<TResult, TVariables>(document, variables, options, true)\n\n  function load (\n    document?: DocumentNode,\n    variables?: TVariables,\n    options?: UseQueryOptions,\n  ) {\n    if (document) {\n      query.document.value = document\n    }\n    if (variables) {\n      query.variables.value = variables\n    }\n    if (options) {\n      Object.assign(isRef(query.options) ? query.options.value : query.options, options)\n    }\n    query.forceDisabled.value = false\n  }\n\n  return {\n    ...query,\n    load,\n  }\n}\n","import { DocumentNode } from 'graphql'\nimport { MutationOptions, OperationVariables, FetchResult, TypedDocumentNode, ApolloError } from '@apollo/client/core/index.js'\nimport { ref, onBeforeUnmount, isRef, Ref, getCurrentInstance } from 'vue-demi'\nimport { useApolloClient } from './useApolloClient'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { useEventHook } from './util/useEventHook'\nimport { trackMutation } from './util/loadingTracking'\nimport { toApolloError } from './util/toApolloError'\n\n/**\n * `useMutation` options for mutations that don't require `variables`.\n */\nexport interface UseMutationOptions<\n  TResult = any,\n  TVariables = OperationVariables\n> extends Omit<MutationOptions<TResult, TVariables>, 'mutation'> {\n  clientId?: string\n  throws?: 'auto' | 'always' | 'never'\n}\n\ntype DocumentParameter<TResult, TVariables> = DocumentNode | Ref<DocumentNode> | ReactiveFunction<DocumentNode> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables>> | ReactiveFunction<TypedDocumentNode<TResult, TVariables>>\ntype OptionsParameter<TResult, TVariables> = UseMutationOptions<TResult, TVariables> | Ref<UseMutationOptions<TResult, TVariables>> | ReactiveFunction<UseMutationOptions<TResult, TVariables>>\n\nexport type MutateOverrideOptions<TResult> = Pick<UseMutationOptions<TResult, OperationVariables>, 'update' | 'optimisticResponse' | 'context' | 'updateQueries' | 'refetchQueries' | 'awaitRefetchQueries' | 'errorPolicy' | 'fetchPolicy' | 'clientId'>\nexport type MutateResult<TResult> = Promise<FetchResult<TResult, Record<string, any>, Record<string, any>> | null>\nexport type MutateFunction<TResult, TVariables> = (variables?: TVariables | null, overrideOptions?: MutateOverrideOptions<TResult>) => MutateResult<TResult>\n\nexport interface UseMutationReturn<TResult, TVariables> {\n  mutate: MutateFunction<TResult, TVariables>\n  loading: Ref<boolean>\n  error: Ref<ApolloError | null>\n  called: Ref<boolean>\n  onDone: (fn: (param: FetchResult<TResult, Record<string, any>, Record<string, any>>) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError) => void) => {\n    off: () => void\n  }\n}\n\nexport function useMutation<\n  TResult = any,\n  TVariables extends OperationVariables = OperationVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  options: OptionsParameter<TResult, TVariables> = {},\n): UseMutationReturn<TResult, TVariables> {\n  const vm = getCurrentInstance()\n  const loading = ref<boolean>(false)\n  vm && trackMutation(loading)\n  const error = ref<ApolloError | null>(null)\n  const called = ref<boolean>(false)\n\n  const doneEvent = useEventHook<FetchResult<TResult, Record<string, any>, Record<string, any>>>()\n  const errorEvent = useEventHook<ApolloError>()\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  async function mutate (variables?: TVariables | null, overrideOptions: Omit<UseMutationOptions<TResult, TVariables>, 'variables'> = {}) {\n    let currentDocument: DocumentNode\n    if (typeof document === 'function') {\n      currentDocument = document()\n    } else if (isRef(document)) {\n      currentDocument = document.value\n    } else {\n      currentDocument = document\n    }\n\n    let currentOptions: UseMutationOptions<TResult, TVariables>\n    if (typeof options === 'function') {\n      currentOptions = options()\n    } else if (isRef(options)) {\n      currentOptions = options.value\n    } else {\n      currentOptions = options\n    }\n    const client = resolveClient(currentOptions.clientId)\n    error.value = null\n    loading.value = true\n    called.value = true\n    try {\n      const result = await client.mutate<TResult, TVariables>({\n        mutation: currentDocument,\n        ...currentOptions,\n        ...overrideOptions,\n        variables: (variables ?? currentOptions.variables)\n          ? {\n            ...(currentOptions.variables as TVariables),\n            ...(variables as TVariables),\n          }\n          : undefined,\n      })\n      loading.value = false\n      doneEvent.trigger(result)\n      return result\n    } catch (e) {\n      const apolloError = toApolloError(e)\n      error.value = apolloError\n      loading.value = false\n      errorEvent.trigger(apolloError)\n      if (currentOptions.throws === 'always' || (currentOptions.throws !== 'never' && !errorEvent.getCount())) {\n        throw apolloError\n      }\n    }\n    return null\n  }\n\n  vm && onBeforeUnmount(() => {\n    loading.value = false\n  })\n\n  return {\n    mutate,\n    loading,\n    error,\n    called,\n    onDone: doneEvent.on,\n    onError: errorEvent.on,\n  }\n}\n","import { DocumentNode } from 'graphql'\nimport {\n  Ref,\n  ref,\n  watch,\n  isRef,\n  computed,\n  getCurrentInstance,\n  onBeforeUnmount,\n  nextTick,\n} from 'vue-demi'\nimport type {\n  OperationVariables,\n  SubscriptionOptions,\n  FetchResult,\n  Observable,\n  ObservableSubscription,\n  TypedDocumentNode,\n  ApolloError,\n} from '@apollo/client/core/index.js'\nimport { throttle, debounce } from 'throttle-debounce'\nimport { ReactiveFunction } from './util/ReactiveFunction'\nimport { paramToRef } from './util/paramToRef'\nimport { paramToReactive } from './util/paramToReactive'\nimport { useApolloClient } from './useApolloClient'\nimport { useEventHook } from './util/useEventHook'\nimport { trackSubscription } from './util/loadingTracking'\nimport type { CurrentInstance } from './util/types'\nimport { toApolloError } from './util/toApolloError'\nimport { isServer } from './util/env'\n\nexport interface UseSubscriptionOptions <\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  TResult = any,\n  TVariables = OperationVariables\n> extends Omit<SubscriptionOptions<TVariables>, 'query' | 'variables'> {\n  clientId?: string\n  enabled?: boolean\n  throttle?: number\n  debounce?: number\n}\n\ntype DocumentParameter<TResult, TVariables> = DocumentNode | Ref<DocumentNode> | ReactiveFunction<DocumentNode> | TypedDocumentNode<TResult, TVariables> | Ref<TypedDocumentNode<TResult, TVariables>> | ReactiveFunction<TypedDocumentNode<TResult, TVariables>>\ntype VariablesParameter<TVariables> = TVariables | Ref<TVariables> | ReactiveFunction<TVariables>\ntype OptionsParameter<TResult, TVariables> = UseSubscriptionOptions<TResult, TVariables> | Ref<UseSubscriptionOptions<TResult, TVariables>> | ReactiveFunction<UseSubscriptionOptions<TResult, TVariables>>\n\nexport interface UseSubscriptionReturn<TResult, TVariables> {\n  result: Ref<TResult | null | undefined>\n  loading: Ref<boolean>\n  error: Ref<ApolloError | null>\n  start: () => void\n  stop: () => void\n  restart: () => void\n  document: Ref<DocumentNode>\n  variables: Ref<TVariables | undefined>\n  options: UseSubscriptionOptions<TResult, TVariables> | Ref<UseSubscriptionOptions<TResult, TVariables>>\n  subscription: Ref<Observable<FetchResult<TResult, Record<string, any>, Record<string, any>>> | null>\n  onResult: (fn: (param: FetchResult<TResult, Record<string, any>, Record<string, any>>) => void) => {\n    off: () => void\n  }\n  onError: (fn: (param: ApolloError) => void) => {\n    off: () => void\n  }\n}\n\n/**\n * Use a subscription that does not require variables or options.\n * */\nexport function useSubscription<TResult = any> (\n  document: DocumentParameter<TResult, undefined>\n): UseSubscriptionReturn<TResult, undefined>\n\n/**\n * Use a subscription that requires options but not variables.\n */\nexport function useSubscription<TResult = any> (\n  document: DocumentParameter<TResult, undefined>,\n  variables: undefined | null,\n  options: OptionsParameter<TResult, null>\n): UseSubscriptionReturn<TResult, null>\n\n/**\n * Use a subscription that requires variables.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>\n): UseSubscriptionReturn<TResult, TVariables>\n\n/**\n * Use a subscription that has optional variables.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n): UseSubscriptionReturn<TResult, TVariables>\n\n/**\n * Use a subscription that requires variables and options.\n */\nexport function useSubscription<TResult = any, TVariables extends OperationVariables = OperationVariables> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables>,\n  options: OptionsParameter<TResult, TVariables>\n): UseSubscriptionReturn<TResult, TVariables>\n\nexport function useSubscription <\n  TResult,\n  TVariables\n> (\n  document: DocumentParameter<TResult, TVariables>,\n  variables: VariablesParameter<TVariables> | undefined = undefined,\n  options: OptionsParameter<TResult, TVariables> = {},\n): UseSubscriptionReturn<TResult, TVariables> {\n  // Is on server?\n  const vm = getCurrentInstance() as CurrentInstance | null\n\n  const documentRef = paramToRef(document)\n  const variablesRef = paramToRef(variables)\n  const optionsRef = paramToReactive(options)\n\n  const result = ref<TResult | null | undefined>()\n  const resultEvent = useEventHook<FetchResult<TResult>>()\n  const error = ref<ApolloError | null>(null)\n  const errorEvent = useEventHook<ApolloError>()\n\n  const loading = ref(false)\n  vm && trackSubscription(loading)\n\n  // Apollo Client\n  const { resolveClient } = useApolloClient()\n\n  const subscription: Ref<Observable<FetchResult<TResult>> | null> = ref(null)\n  let observer: ObservableSubscription | null = null\n  let started = false\n\n  function start () {\n    if (started || !isEnabled.value || isServer) return\n    started = true\n    loading.value = true\n\n    const client = resolveClient(currentOptions.value?.clientId)\n\n    // @ts-expect-error apollo-client types issue with TVariables\n    subscription.value = client.subscribe<TResult, TVariables>({\n      query: currentDocument,\n      variables: currentVariables,\n      ...currentOptions.value,\n    })\n\n    observer = subscription.value.subscribe({\n      next: onNextResult,\n      error: onError,\n    })\n  }\n\n  function onNextResult (fetchResult: FetchResult<TResult>) {\n    result.value = fetchResult.data\n    loading.value = false\n    resultEvent.trigger(fetchResult)\n  }\n\n  function onError (fetchError: unknown) {\n    const apolloError = toApolloError(fetchError)\n\n    error.value = apolloError\n    loading.value = false\n    errorEvent.trigger(apolloError)\n  }\n\n  function stop () {\n    if (!started) return\n    started = false\n    loading.value = false\n\n    if (subscription.value) {\n      subscription.value = null\n    }\n\n    if (observer) {\n      observer.unsubscribe()\n      observer = null\n    }\n  }\n\n  // Restart\n  let restarting = false\n  /**\n   * Queue a restart of the query (on next tick) if it is already active\n   */\n  function baseRestart () {\n    if (!started || restarting) return\n    restarting = true\n    // eslint-disable-next-line @typescript-eslint/no-floating-promises\n    nextTick(() => {\n      if (started) {\n        stop()\n        start()\n      }\n      restarting = false\n    })\n  }\n\n  let debouncedRestart: typeof baseRestart\n  function updateRestartFn () {\n    if (currentOptions.value?.throttle) {\n      debouncedRestart = throttle(currentOptions.value.throttle, baseRestart)\n    } else if (currentOptions.value?.debounce) {\n      debouncedRestart = debounce(currentOptions.value.debounce, baseRestart)\n    } else {\n      debouncedRestart = baseRestart\n    }\n  }\n\n  function restart () {\n    if (!debouncedRestart) updateRestartFn()\n    debouncedRestart()\n  }\n\n  // Applying options\n  const currentOptions = ref<UseSubscriptionOptions<TResult, TVariables>>()\n  watch(() => isRef(optionsRef) ? optionsRef.value : optionsRef, value => {\n    if (currentOptions.value && (\n      currentOptions.value.throttle !== value.throttle ||\n      currentOptions.value.debounce !== value.debounce\n    )) {\n      updateRestartFn()\n    }\n    currentOptions.value = value\n    restart()\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Applying document\n  let currentDocument: DocumentNode\n  watch(documentRef, value => {\n    currentDocument = value\n    restart()\n  }, {\n    immediate: true,\n  })\n\n  // Applying variables\n  let currentVariables: TVariables | undefined\n  let currentVariablesSerialized: string\n  watch(variablesRef, (value, oldValue) => {\n    const serialized = JSON.stringify(value)\n    if (serialized !== currentVariablesSerialized) {\n      currentVariables = value\n      restart()\n    }\n    currentVariablesSerialized = serialized\n  }, {\n    deep: true,\n    immediate: true,\n  })\n\n  // Internal enabled returned to user\n  // @TODO Doesn't fully work yet, need to initialize with option\n  // const enabled = ref<boolean>()\n  const enabledOption = computed(() => !currentOptions.value || currentOptions.value.enabled == null || currentOptions.value.enabled)\n  // const isEnabled = computed(() => !!((typeof enabled.value === 'boolean' && enabled.value) && enabledOption.value))\n  const isEnabled = enabledOption\n\n  // watch(enabled, value => {\n  //   if (value == null) {\n  //     enabled.value = enabledOption.value\n  //   }\n  // })\n\n  // Auto start & stop\n  watch(isEnabled, value => {\n    if (value) {\n      start()\n    } else {\n      stop()\n    }\n  }, {\n    immediate: true,\n  })\n\n  // Teardown\n  vm && onBeforeUnmount(stop)\n\n  return {\n    result,\n    loading,\n    error,\n    // @TODO doesn't fully work yet\n    // enabled,\n    start,\n    stop,\n    restart,\n    document: documentRef,\n    variables: variablesRef,\n    options: optionsRef,\n    subscription,\n    onResult: resultEvent.on,\n    onError: errorEvent.on,\n  }\n}\n","import { Ref, computed } from 'vue-demi'\nimport { ExtractSingleKey } from './util/ExtractSingleKey'\nimport type { DeepNonNullable, DeepRequired } from 'ts-essentials'\n\nexport type UseResultReturn<T> = Readonly<Ref<Readonly<T>>>\n\n/**\n * Resolve a `result`, returning either the first key of the `result` if there\n * is only one, or the `result` itself. The `value` of the ref will be\n * `undefined` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const user = useResult(result)\n * // user is `undefined` until the query resolves\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @returns Readonly ref with `undefined` or the resolved `result`.\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<TResult, TResultKey extends keyof NonNullable<TResult> = keyof NonNullable<TResult>> (\n  result: Ref<TResult>\n): UseResultReturn<undefined | ExtractSingleKey<NonNullable<TResult>, TResultKey>>\n\n/**\n * Resolve a `result`, returning either the first key of the `result` if there\n * is only one, or the `result` itself. The `value` of the ref will be\n * `defaultValue` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const profile = useResult(result, {})\n * // profile is `{}` until the query resolves\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @param  {TDefaultValue} defaultValue The default return value before `result` is resolved.\n * @returns Readonly ref with the `defaultValue` or the resolved `result`.\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<TResult, TDefaultValue, TResultKey extends keyof NonNullable<TResult> = keyof NonNullable<TResult>> (\n  result: Ref<TResult>,\n  defaultValue: TDefaultValue\n): UseResultReturn<TDefaultValue | ExtractSingleKey<NonNullable<TResult>, TResultKey>>\n\n/**\n * Resolve a `result`, returning the `result` mapped with the `pick` function.\n * The `value` of the ref will be `defaultValue` until it is resolved.\n *\n * @example\n * const { result } = useQuery(...)\n * const comments = useResult(result, undefined, (data) => data.comments)\n * // user is `undefined`, then resolves to the result's `comments`\n *\n * @param  {Ref<TResult>} result A `result` returned from `useQuery` to resolve.\n * @param  {TDefaultValue} defaultValue The default return value before `result` is resolved.\n * @param  {(data:TResult)=>TReturnValue} pick The function that receives `result` and maps a return value from it.\n * @returns Readonly ref with the `defaultValue` or the resolved and `pick`-mapped `result`\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<\n  TResult,\n  TDefaultValue,\n  TReturnValue,\n> (\n  result: Ref<TResult>,\n  defaultValue: TDefaultValue | undefined,\n  pick: (data: DeepRequired<DeepNonNullable<TResult>>) => TReturnValue\n): UseResultReturn<TDefaultValue | TReturnValue>\n\n/**\n * @deprecated Use `computed` instead. Before: `const items = useResult(result, [], data => data.someField.myItems)` After: `const items = computed(() => result.value?.someField.myItems ?? [])`\n */\nexport function useResult<\n  TResult,\n  TDefaultValue,\n  TReturnValue,\n> (\n  result: Ref<TResult>,\n  defaultValue?: TDefaultValue,\n  pick?: (data: DeepRequired<DeepNonNullable<TResult>>) => TReturnValue,\n): UseResultReturn<TResult | TResult[keyof TResult] | TDefaultValue | TReturnValue | undefined> {\n  console.warn(`'useResult' is deprecated and will be removed soon. Please use 'computed' instead.\nBefore:\nconst items = useResult(result, [], data => data.someField.myItems)\nAfter:\nconst items = computed(() => result.value?.someField.myItems ?? [])`)\n  return computed(() => {\n    const value = result.value\n    if (value) {\n      if (pick) {\n        try {\n          return pick(value as DeepRequired<DeepNonNullable<TResult>>)\n        } catch (e) {\n          // Silent error\n        }\n      } else {\n        const keys = Object.keys(value)\n        if (keys.length === 1) {\n          // Automatically take the only key in result data\n          return value[keys[0] as keyof TResult]\n        } else {\n          // Return entire result data\n          return value\n        }\n      }\n    }\n    return defaultValue\n  })\n}\n","import { getCurrentTracking, getAppTracking } from './util/loadingTracking'\nimport { computed } from 'vue-demi'\n\nexport function useQueryLoading () {\n  const { tracking } = getCurrentTracking()\n  return computed(() => tracking.queries.value > 0)\n}\n\nexport function useMutationLoading () {\n  const { tracking } = getCurrentTracking()\n  return computed(() => tracking.mutations.value > 0)\n}\n\nexport function useSubscriptionLoading () {\n  const { tracking } = getCurrentTracking()\n  return computed(() => tracking.subscriptions.value > 0)\n}\n\nexport function useGlobalQueryLoading () {\n  const { appTracking } = getAppTracking()\n  return computed(() => appTracking.queries.value > 0)\n}\n\nexport function useGlobalMutationLoading () {\n  const { appTracking } = getAppTracking()\n  return computed(() => appTracking.mutations.value > 0)\n}\n\nexport function useGlobalSubscriptionLoading () {\n  const { appTracking } = getAppTracking()\n  return computed(() => appTracking.subscriptions.value > 0)\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}